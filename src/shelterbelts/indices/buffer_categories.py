import os
import argparse

import numpy as np
import xarray as xr
import rioxarray as rxr
from scipy.ndimage import binary_dilation
from rasterio.enums import Resampling
from skimage.morphology import skeletonize # I think skeletonize centres the result slightly better than thinning

from shelterbelts.apis.worldcover import tif_categorical, visualise_categories
from shelterbelts.indices.cover_categories import cover_categories_cmap, cover_categories_labels

buffer_cmap = {
    15:(29, 153, 105),
    16:(127, 168, 57),
    17:(129, 146, 124) # (122, 128, 123)  # (49, 71, 31)
}
buffer_labels = {
    15:'Trees in Gullies',
    16:'Trees on Ridges',
    17:'Trees next to Roads'
}
buffer_categories_cmap = cover_categories_cmap | buffer_cmap
buffer_categories_labels = cover_categories_labels | buffer_labels
inverted_labels = {v: k for k, v in buffer_categories_labels.items()}


def buffer_categories(cover_data, gullies_data, ridges_data=None, roads_data=None, outdir=".", stub="TEST", buffer_width=3, savetif=True, plot=True):
    """Reclassify relevant corridors as riparian buffers and ridge buffers.
    
    Parameters
    ----------
    cover_data : str, xarray.Dataset, or xarray.DataArray
        Integer tif file generated by cover_categories.py.
    gullies_data : str, xarray.Dataset, or xarray.DataArray
        Boolean tif file generated by either hydrolines.py or catchments.py.
    ridges_data : str, xarray.Dataset, or xarray.DataArray, optional
        Boolean tif file generated by catchments.py.
    roads_data : str, xarray.Dataset, or xarray.DataArray, optional
        Boolean tif file generated by osm.py or hydrolines.py.
    outdir : str, optional
        Output directory to save results. Default is current directory.
    stub : str, optional
        Prefix for output files. Default is 'TEST'.
    buffer_width : int, optional
        Number of pixels away from the feature that still counts as within the buffer. Default is 3.
    savetif : bool, optional
        Whether to save the results as a GeoTIFF file. Default is True.
    plot : bool, optional
        Whether to generate a PNG visualisation of the results. Default is True.

    Returns
    -------
    xarray.Dataset
        Dataset with 'buffer_categories' band, where integers represent categories defined in 'buffer_categories_labels'.

    Notes
    -------
    When savetif=True, it outputs a GeoTIFF file with embedded color map:
    ``{stub}_buffer_categories.tif``
    
    When plot=True, it outputs a PNG visualisation with legend:
    ``{stub}_buffer_categories.png``
    
    Examples
    --------
    Using file paths as input:
    
    >>> from shelterbelts.utils.filepaths import get_filename
    >>> cover_file = get_filename('g2_26729_cover_categories.tif')
    >>> gullies_file = get_filename('g2_26729_DEM-S_gullies.tif')
    >>> ds = buffer_categories(cover_file, gullies_file, outdir='/tmp', plot=False, savetif=False)
    >>> 'buffer_categories' in set(ds.data_vars)
    True
    
    Using Datasets as input:
    
    >>> import rioxarray as rxr
    >>> da_cover = rxr.open_rasterio(cover_file).squeeze('band').drop_vars('band')
    >>> ds_cover = da_cover.to_dataset(name='cover_categories')
    >>> da_gullies = rxr.open_rasterio(gullies_file).squeeze('band').drop_vars('band')
    >>> ds_gullies = da_gullies.to_dataset(name='gullies')
    >>> ds = buffer_categories(ds_cover, ds_gullies, outdir='/tmp', plot=False, savetif=False)
    >>> 'buffer_categories' in set(ds.data_vars)
    True
    
    Here's how different parameters affect the buffer categorization:
    
    .. plot::

        from shelterbelts.indices.buffer_categories import buffer_categories, buffer_categories_cmap, buffer_categories_labels
        from shelterbelts.utils.filepaths import get_filename
        from shelterbelts.utils.visualisation import visualise_categories_sidebyside

        cover_file = get_filename('g2_26729_cover_categories.tif')
        gullies_file = get_filename('g2_26729_DEM-S_gullies.tif')
        ridges_file = get_filename('g2_26729_DEM-S_ridges.tif')
        roads_file = get_filename('g2_26729_roads.tif')
        
        # buffer_width: 1 vs 5 pixels (gullies only)
        ds1 = buffer_categories(cover_file, gullies_file, outdir='/tmp', stub='buf1', plot=False, savetif=False, buffer_width=1)
        ds2 = buffer_categories(cover_file, gullies_file, outdir='/tmp', stub='buf5', plot=False, savetif=False, buffer_width=5)
        visualise_categories_sidebyside(
            ds1['buffer_categories'], ds2['buffer_categories'],
            colormap=buffer_categories_cmap, labels=buffer_categories_labels,
            title1="buffer_width=1", title2="buffer_width=5"
        )
        
        # gullies+roads vs gullies+roads+ridges
        ds_gul_roads = buffer_categories(cover_file, gullies_file, roads_data=roads_file, outdir='/tmp', stub='gul_roads', plot=False, savetif=False, buffer_width=3)
        ds_all = buffer_categories(cover_file, gullies_file, ridges_data=ridges_file, roads_data=roads_file, outdir='/tmp', stub='gul_rid_roads', plot=False, savetif=False, buffer_width=3)
        visualise_categories_sidebyside(
            ds_gul_roads['buffer_categories'], ds_all['buffer_categories'],
            colormap=buffer_categories_cmap, labels=buffer_categories_labels,
            title1="Gullies + Roads", title2="Gullies + Roads + Ridges"
        )
    """
    if isinstance(cover_data, str):
        da_cover = rxr.open_rasterio(cover_data).squeeze('band').drop_vars('band')
    elif isinstance(cover_data, xr.Dataset):
        da_cover = cover_data['cover_categories']
    else:
        da_cover = cover_data

    if isinstance(gullies_data, str):
        da_gullies = rxr.open_rasterio(gullies_data).squeeze('band').drop_vars('band')
    elif isinstance(gullies_data, xr.Dataset):
        da_gullies = gullies_data['gullies']
    else:
        da_gullies = gullies_data
    
    da_gullies_reprojected = da_gullies.rio.reproject_match(da_cover, resampling=Resampling.max) # This may downsample, changing the edge width 
    gullies_thinned = skeletonize(da_gullies_reprojected.values) # This makes the edges 1 wide again

    y, x = np.ogrid[-buffer_width:buffer_width+1, -buffer_width:buffer_width+1]
    gap_kernel = (x**2 + y**2 <= buffer_width**2)
    buffered_gullies = binary_dilation(da_gullies_reprojected.values, structure=gap_kernel)
    
    # Can adjust depending on which category we want to take precedence
    # categories_to_override = [10, 11, 12, 13, 14]
    categories_to_override = [10, 11, 14]
    uncategorised_trees = np.isin(da_cover, categories_to_override)
    
    riparian_trees = uncategorised_trees & buffered_gullies
    da_buffered = da_cover.where(~riparian_trees, 15)  # Assigning gully trees label 15
    
    ds = da_cover.to_dataset(name="cover_categories")
    ds['gullies'] = (('y', 'x'), da_gullies_reprojected.values)

    if ridges_data:
        if isinstance(ridges_data, str):
            da_ridges = rxr.open_rasterio(ridges_data).squeeze('band').drop_vars('band')
        elif isinstance(ridges_data, xr.Dataset):
            da_ridges = ridges_data['ridges']
        else:
            da_ridges = ridges_data
        da_ridges_reprojected = da_ridges.rio.reproject_match(da_cover, resampling=Resampling.max)
        ridges_thinned = skeletonize(da_ridges_reprojected.values)
        ridges_thinned = ridges_thinned & ~buffered_gullies
        buffered_ridges = binary_dilation(ridges_thinned, structure=gap_kernel)
        uncategorised_trees = (da_buffered == 14)  # Currently unlabelled trees
        ridge_trees = uncategorised_trees & buffered_ridges
        da_buffered = da_buffered.where(~ridge_trees, 16)   # Assigning ridge trees label 16
        ds['ridges'] = (('y', 'x'), da_ridges_reprojected.values)

    da_roads = None
    if roads_data:
        if isinstance(roads_data, str):
            da_roads = rxr.open_rasterio(roads_data).squeeze('band').drop_vars('band')
        elif isinstance(roads_data, xr.Dataset):
            da_roads = roads_data['roads']
        else:
            da_roads = roads_data  # xr.DataArray
    if da_roads is not None:
        da_roads_reprojected = da_roads.rio.reproject_match(da_cover, resampling=Resampling.max)
        roads_thinned = skeletonize(da_roads_reprojected.values)

        uncategorised_trees = np.isin(da_buffered, categories_to_override)

        buffered_roads = binary_dilation(roads_thinned, structure=gap_kernel)
        road_trees = uncategorised_trees & buffered_roads
        da_buffered = da_buffered.where(~road_trees, 17)   # Assigning road trees label 17
        ds['roads'] = (('y', 'x'), da_roads_reprojected.values)
    
    ds['buffer_categories'] = (('y', 'x'), da_buffered.values)

    if savetif:
        filename = os.path.join(outdir,f"{stub}_buffer_categories.tif")
        tif_categorical(ds['buffer_categories'], filename, buffer_categories_cmap)
    
    if plot:
        filename_png = os.path.join(outdir, f"{stub}_buffer_categories.png")
        visualise_categories(ds['buffer_categories'], filename_png, buffer_categories_cmap, buffer_categories_labels, "Buffer Categories")
    
    return ds


def parse_arguments():
    """Parse command line arguments with default values."""
    parser = argparse.ArgumentParser()
    
    parser.add_argument('--cover_data', help='Integer tif file generated by cover_categories.py')
    parser.add_argument('--gullies_data', help='Boolean tif file generated by either hydrolines.py or catchments.py')
    parser.add_argument('--ridges_data', default=None, help='Boolean tif file generated by catchments.py')
    parser.add_argument('--roads_data', default=None, help='Boolean tif file generated by apis/osm.py')
    parser.add_argument('--outdir', default='.', help='The output directory to save the results')
    parser.add_argument('--stub', default='TEST', help='Prefix for output files.')
    parser.add_argument('--buffer_width', default=3, type=int, help='Number of pixels away from the feature that still counts as within the buffer')
    parser.add_argument('--no-savetif', dest='savetif', action="store_false", default=True, help="Disable saving GeoTIFF output (default: enabled)")
    parser.add_argument('--no-plot', dest='plot', action="store_false", default=True, help="Disable PNG visualisation (default: enabled)")

    return parser

if __name__ == '__main__':

    parser = parse_arguments()
    args = parser.parse_args()

    buffer_categories(
        args.cover_data,
        args.gullies_data,
        ridges_data=args.ridges_data,
        roads_data=args.roads_data,
        outdir=args.outdir,
        stub=args.stub,
        buffer_width=args.buffer_width,
        savetif=args.savetif,
        plot=args.plot
    )


# +
# outdir = "../../../outdir/"
# stub = "g2_26729"
# buffer_width=3

# cover_tif = os.path.join(outdir, f"{stub}_cover_categories.tif")
# gullies_tif = os.path.join(outdir, f"{stub}_5m_gullies.tif")
# ridges_tif = os.path.join(outdir, f"{stub}_5m_ridges.tif")
# roads_tif = os.path.join(outdir, f"{stub}_roads.tif")

# buffer_categories(cover_tif, gullies_tif, ridges_tif, roads_tif, outdir, stub)
# -



# +
import os
import argparse

import numpy as np
import rioxarray as rxr
from scipy.ndimage import binary_dilation
from rasterio.enums import Resampling
from skimage.morphology import skeletonize # I think skeletonize centers the result slightly better than thinning

import matplotlib.pyplot as plt

from shelterbelts.apis.worldcover import tif_categorical, visualise_categories
from shelterbelts.indices.cover_categories import cover_categories_cmap, cover_categories_labels
# -

buffer_cmap = {
    15:(29, 153, 105),
    16:(127, 168, 57),
    17:(129, 146, 124) # (122, 128, 123)  # (49, 71, 31)
}
buffer_labels = {
    15:'Trees in Gullies',
    16:'Trees on Ridges',
    17:'Trees next to Roads'
}
buffer_categories_cmap = cover_categories_cmap | buffer_cmap
buffer_categories_labels = cover_categories_labels | buffer_labels
inverted_labels = {v: k for k, v in buffer_categories_labels.items()}


def buffer_categories(cover_tif, gullies_tif, ridges_tif=None, roads_tif=None, outdir=".", stub="TEST", buffer_width=3, savetif=True, plot=True, ds=None, ds_gullies=None, ds_roads=None):
    """Reclassify relevant corridors as riparian buffers and ridge buffers.
    
    Parameters
    ----------
        cover_tif: Integer tif file generated by cover_categories.py
        gullies_tif: Boolean tif file generated by either hydrolines.py or catchments.py
        ridges_tif: Boolean tif file generated by catchments.py
        roads_tif: Boolean tif file generated by apis/osm.py
        buffer_width: Number of pixels away from the feature that still counts as within the buffer
        ds: Used instead of the cover_tif when provided to avoid writing and reading lots of data.

    Returns
    -------
        ds: an xarray with a band 'buffer_categories', where the integers represent the categories defined in 'buffer_category_labels'.

    Downloads
    ---------
        buffer_categories.tif: A tif file of the 'buffer_categories' band in ds, with colours embedded.
        buffer_categories.png: A png file like the tif file, but with a legend as well.
    
    Examples
    --------
    **buffer_width effect** - controls distance from features to include in buffer:
    
    .. plot::
        
        from shelterbelts.indices.buffer_categories import buffer_categories, buffer_category_cmap, buffer_category_labels
        from shelterbelts.utils import visualise_categories_sidebyside, get_example_data
        
        test_filename = get_example_data('g2_26729_binary_tree_cover_10m.tiff')
        ds1 = buffer_categories(test_filename, buffer_width=1)
        ds2 = buffer_categories(test_filename, buffer_width=5)
        visualise_categories_sidebyside(
            ds1['buffer_categories'], 
            ds2['buffer_categories'],
            colormap=buffer_category_cmap,
            labels=buffer_category_labels,
            title1="buffer_width=1 (narrow)",
            title2="buffer_width=5 (wide)"
        )
    
    """
    if not ds: 
        da_cover = rxr.open_rasterio(cover_tif).isel(band=0).drop_vars('band')
    else: 
        da_cover = ds['cover_categories']

    if not ds_gullies: 
        da_gullies = rxr.open_rasterio(gullies_tif).isel(band=0).drop_vars('band')
    else: 
        # Might be cleaner to pass just one ds with the cover_categories and gullies as separate variables
        da_gullies = ds_gullies['gullies']
    
    da_gullies_reprojected = da_gullies.rio.reproject_match(da_cover, resampling=Resampling.max) # This may downsample, changing the edge width 
    gullies_thinned = skeletonize(da_gullies_reprojected.values) # This makes the edges 1 wide again

    y, x = np.ogrid[-buffer_width:buffer_width+1, -buffer_width:buffer_width+1]
    gap_kernel = (x**2 + y**2 <= buffer_width**2)
    buffered_gullies = binary_dilation(da_gullies_reprojected.values, structure=gap_kernel)
    
    # Can adjust depending on which category we want to take precedence
    # categories_to_override = [10, 11, 12, 13, 14]
    categories_to_override = [10, 11, 14]
    uncategorised_trees = np.isin(da_cover, categories_to_override)
    
    riparian_trees = uncategorised_trees & buffered_gullies
    da_buffered = da_cover.where(~riparian_trees, 15)  # Assigning gully trees label 15
    
    ds = da_cover.to_dataset(name="cover_categories")
    ds['gullies'] = (('y', 'x'), da_gullies_reprojected.values)

    if ridges_tif:
        da_ridges = rxr.open_rasterio(ridges_tif).isel(band=0)
        da_ridges_reprojected = da_ridges.rio.reproject_match(da_cover, resampling=Resampling.max)
        ridges_thinned = skeletonize(da_ridges_reprojected.values)
        ridges_thinned = ridges_thinned & ~buffered_gullies
        buffered_ridges = binary_dilation(ridges_thinned, structure=gap_kernel)
        uncategorised_trees = (da_buffered == 14)  # Currently unlabelled trees
        ridge_trees = uncategorised_trees & buffered_ridges
        da_buffered = da_buffered.where(~ridge_trees, 16)   # Assigning ridge trees label 16
        ds['ridges'] = (('y', 'x'), da_ridges_reprojected.values)

    da_roads = None
    if roads_tif is not None:
        da_roads = rxr.open_rasterio(roads_tif).isel(band=0)
    elif ds_roads is not None:
        da_roads = ds_roads['gullies'] # Hacky way to re-use the hydrolines code for roads. Should refactor hydrolines.py
    if da_roads is not None:
        da_roads_reprojected = da_roads.rio.reproject_match(da_cover, resampling=Resampling.max)
        roads_thinned = skeletonize(da_roads_reprojected.values)

        uncategorised_trees = np.isin(da_buffered, categories_to_override)

        buffered_roads = binary_dilation(roads_thinned, structure=gap_kernel)
        road_trees = uncategorised_trees & buffered_roads
        da_buffered = da_buffered.where(~road_trees, 17)   # Assigning road trees label 17
        ds['roads'] = (('y', 'x'), da_roads_reprojected.values)
    
    ds['buffer_categories'] = (('y', 'x'), da_buffered.values)

    if savetif:
        filename = os.path.join(outdir,f"{stub}_buffer_categories.tif")
        tif_categorical(ds['buffer_categories'], filename, buffer_categories_cmap)
    
    if plot:
        filename_png = os.path.join(outdir, f"{stub}_buffer_categories.png")
        visualise_categories(ds['buffer_categories'], filename_png, buffer_categories_cmap, buffer_categories_labels, "Buffer Categories")
    
    # ds = ds.rename({'x':'longitude', 'y': 'latitude'})

    return ds


def parse_arguments():
    """Parse command line arguments with default values."""
    parser = argparse.ArgumentParser()
    
    parser.add_argument('--cover_tif', help='Integer tif file generated by cover_categories.py')
    parser.add_argument('--gullies_tif', help='Boolean tif file generated by either hydrolines.py or catchments.py')
    parser.add_argument('--ridges_tif', default=None, help='Boolean tif file generated by catchments.py')
    parser.add_argument('--outdir', default='.', help='The output directory to save the results')
    parser.add_argument('--stub', default=None, help='Prefix for output files.')
    parser.add_argument('--buffer_width', default=3, help='Number of pixels away from the feature that still counts as within the buffer')
    parser.add_argument('--plot', default=False, action="store_true", help="Boolean to Save a png file along with the tif")

    return parser.parse_args()

if __name__ == '__main__':

    args = parse_arguments()

    cover_tif = args.cover_tif
    gullies_tif = args.gullies_tif
    ridges_tif = args.ridges_tif
    outdir = args.outdir
    stub = args.stub
    buffer_width = int(args.buffer_width)
    plot = args.plot

    buffer_categories(cover_tif, gullies_tif, ridges_tif, outdir, stub, buffer_width, save_tif=True, plot=plot)


# +
# outdir = "../../../outdir/"
# stub = "g2_26729"
# buffer_width=3

# cover_tif = os.path.join(outdir, f"{stub}_cover_categories.tif")
# gullies_tif = os.path.join(outdir, f"{stub}_5m_gullies.tif")
# ridges_tif = os.path.join(outdir, f"{stub}_5m_ridges.tif")
# roads_tif = os.path.join(outdir, f"{stub}_roads.tif")

# buffer_categories(cover_tif, gullies_tif, ridges_tif, roads_tif, outdir, stub)
# -




import os
import argparse

import xarray as xr
import rioxarray as rxr

from shelterbelts.utils.visualization import tif_categorical, visualise_categories
from shelterbelts.apis.worldcover import worldcover_cmap, worldcover_labels
from shelterbelts.indices.tree_categories import tree_categories_cmap, tree_categories_labels
from shelterbelts.indices.shelter_categories import shelter_categories_labels as shelter_labels, shelter_categories_cmap


cover_cmap = {  
    31: (0, 0, 0),
    32: (255, 255, 76),
    41: (0, 0, 0),
    42: (240, 150, 255)
}

cover_labels = {
    31: "Unsheltered Grassland",
    32: "Sheltered Grassland",
    41: "Unsheltered Cropland",
    42: "Sheltered Cropland"
}

cover_categories_labels = tree_categories_labels | worldcover_labels | cover_labels | shelter_labels
cover_categories_cmap = tree_categories_cmap | worldcover_cmap | shelter_categories_cmap | cover_cmap
inverted_labels = {v: k for k, v in cover_categories_labels.items()}


def cover_categories(shelter_data, worldcover_data, outdir='.', stub='TEST', savetif=True, plot=True):
    """Reclassify non-tree pixels with categories from worldcover
    
    Parameters
    ----------
    shelter_data : str, xarray.Dataset, or xarray.DataArray
        File path to integer tif generated by shelter_categories.py, or a Dataset/DataArray
        containing the 'shelter_categories' band.
    worldcover_data : str or xarray.DataArray
        File path to integer tif generated by apis.worldcover.py, or a DataArray.
    outdir : str, optional
        Output directory to save the results. Default is current directory.
    stub : str, optional
        Prefix for output files. Default is 'TEST'.
    savetif : bool, optional
        Whether to save the results as a GeoTIFF file. Default is True.
    plot : bool, optional
        Whether to generate a PNG visualization of the results. Default is True.
            
    Returns
    -------
    xarray.Dataset
        Dataset containing 'cover_categories' band, where the integers represent the categories 
        defined in 'cover_categories_labels'.

    Notes
    -------
    When savetif=True, it outputs a GeoTIFF file with embedded color map:
    ``{stub}_cover_categories.tif``
    
    When plot=True, it outputs a PNG visualization with legend:
    ``{stub}_cover_categories.png``

    Examples
    --------
    Using file paths as input:
    
    >>> from shelterbelts.utils.filepaths import get_filename
    >>> shelter_file = get_filename('g2_26729_shelter_categories.tif')
    >>> worldcover_file = get_filename('g2_26729_worldcover.tif')
    >>> ds_cover = cover_categories(shelter_file, worldcover_file, outdir='/tmp', plot=False, savetif=False)
    >>> 'cover_categories' in set(ds_cover.data_vars)
    True

    Using datasets as input:

    >>> import rioxarray as rxr
    >>> da_shelter = rxr.open_rasterio(shelter_file).squeeze('band').drop_vars('band')
    >>> da_worldcover = rxr.open_rasterio(worldcover_file).squeeze('band').drop_vars('band')
    >>> ds_cover = cover_categories(da_shelter, da_worldcover, outdir='/tmp', plot=False, savetif=False)
    >>> set(ds_cover.coords) == {'x', 'y', 'spatial_ref'}
    True

    Visualising the cover categories:    
    
    .. plot::

        from shelterbelts.indices.cover_categories import cover_categories, cover_categories_cmap, cover_categories_labels
        from shelterbelts.utils.filepaths import get_filename
        from shelterbelts.utils.visualization import visualise_categories
        
        shelter_file = get_filename('g2_26729_shelter_categories.tif')
        worldcover_file = get_filename('g2_26729_worldcover.tif')
        
        ds_cover = cover_categories(shelter_file, worldcover_file, outdir='/tmp', plot=False, savetif=False)
        visualise_categories(
            ds_cover['cover_categories'],
            colormap=cover_categories_cmap, labels=cover_categories_labels,
            title="Cover Categories"
        )
    
    """
    if isinstance(shelter_data, str):
        da_shelter = rxr.open_rasterio(shelter_data).squeeze('band').drop_vars('band')
    elif isinstance(shelter_data, xr.Dataset):
        da_shelter = shelter_data['shelter_categories']
    else:
        da_shelter = shelter_data

    if isinstance(worldcover_data, str):
        da_worldcover = rxr.open_rasterio(worldcover_data).squeeze('band').drop_vars('band')
    else:
        da_worldcover = worldcover_data

    da_worldcover2 = da_worldcover.rio.reproject_match(da_shelter)

    # Unfortunately this removes the crs
    # I could do it like this, but I think this is less readable
    # da_override_trees = da_shelter.where((da_shelter >= 10) & (da_shelter < 20), da_shelter, da_worldcover2)
    da_override_trees = xr.where((da_shelter >= 10) & (da_shelter < 20), da_shelter, da_worldcover2)

    # Reassign pixels labelled by worldcover as tree but the shelter_tif as not tree, into grassland
    # I'm assuming that the shelter_tif is more accurate than the worldcover_tif in terms of classifying tree vs no tree
    da_override_grass = xr.where((da_override_trees == inverted_labels['Tree cover']), inverted_labels['Grassland'], da_override_trees)

    sheltered_grass = (da_override_grass == inverted_labels['Grassland']) & (da_shelter == inverted_labels['Sheltered'])
    unsheltered_grass = (da_override_grass == inverted_labels['Grassland']) & (da_shelter == inverted_labels['Unsheltered'])
    sheltered_crop = (da_override_grass == inverted_labels['Cropland']) & (da_shelter == inverted_labels['Sheltered'])
    unsheltered_crop = (da_override_grass == inverted_labels['Cropland']) & (da_shelter == inverted_labels['Unsheltered'])

    da = da_override_grass
    da = xr.where(sheltered_grass, inverted_labels['Sheltered Grassland'], da)
    da = xr.where(unsheltered_grass, inverted_labels['Unsheltered Grassland'], da)
    da = xr.where(sheltered_crop, inverted_labels['Sheltered Cropland'], da)
    da = xr.where(unsheltered_crop, inverted_labels['Unsheltered Cropland'], da)

    # Re-override the water and urban areas with urban categories, because the lidar doesn't seem to be accurate in these categories.
    da = xr.where(da_worldcover2 == inverted_labels['Permanent water bodies'], inverted_labels['Permanent water bodies'], da)
    da = xr.where(da_worldcover2 == inverted_labels['Built-up'], inverted_labels['Built-up'], da)
    
    ds = da.to_dataset(name='cover_categories')

    # Reassign the crs 
    ds.rio.write_crs(da_shelter.rio.crs, inplace=True)

    if savetif:
        filename = os.path.join(outdir,f"{stub}_cover_categories.tif")
        tif_categorical(ds['cover_categories'], filename, cover_categories_cmap)

    if plot:
        filename_png = os.path.join(outdir, f"{stub}_cover_categories.png")
        visualise_categories(ds['cover_categories'], filename_png, cover_categories_cmap, cover_categories_labels, "Cover Categories")

    return ds


def parse_arguments():
    """Parse command line arguments with default values."""
    parser = argparse.ArgumentParser()
    
    parser.add_argument('--shelter_data', help='Integer tif file generated by shelter_categories.py')
    parser.add_argument('--worldcover_data', help='Integer tif file generated by apis.worldcover.py')
    parser.add_argument('--outdir', default='.', help='The output directory to save the results')
    parser.add_argument('--stub', default='TEST', help='Prefix for output files.')
    parser.add_argument('--no-savetif', dest='savetif', action="store_false", default=True, help="Disable saving GeoTIFF output (default: enabled)")
    parser.add_argument('--no-plot', dest='plot', action="store_false", default=True, help="Disable PNG visualization (default: enabled)")

    return parser

# -

if __name__ == '__main__':
    parser = parse_arguments()
    args = parser.parse_args()

    shelter_data = args.shelter_data
    worldcover_data = args.worldcover_data
    outdir = args.outdir
    stub = args.stub
    plot = args.plot

    ds = cover_categories(shelter_data, worldcover_data, outdir, stub, savetif=True, plot=plot)
